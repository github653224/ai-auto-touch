# 视频流黑屏问题最终解决方案

## 问题描述

视频流模式下，Socket.IO 连接成功，视频帧正在解码（90+ 帧），但 canvas 显示黑屏，没有任何画面。

## 根本原因

我们之前的实现直接使用浏览器原生的 `VideoDecoder` API，但这种方式存在以下问题：

1. **缺少正确的流处理机制**：配置帧和数据帧的顺序没有得到保证
2. **缺少专业的渲染器**：直接使用 Canvas 2D Context 渲染性能较差
3. **缺少尺寸管理**：没有正确处理视频尺寸变化和 canvas 尺寸适配
4. **缺少流式 API**：没有使用 ReadableStream/WritableStream 进行流式处理

## 解决方案

### 1. 安装专业的 Scrcpy 解码库

```bash
npm install @yume-chan/scrcpy @yume-chan/scrcpy-decoder-webcodecs
```

这两个库提供了：
- `@yume-chan/scrcpy`: Scrcpy 协议定义和类型
- `@yume-chan/scrcpy-decoder-webcodecs`: 基于 WebCodecs 的专业视频解码器

### 2. 使用 WebCodecsVideoDecoder

替换原生 `VideoDecoder` 为 `WebCodecsVideoDecoder`，它提供：
- 自动处理配置帧和数据帧的顺序
- 内置的 WebGL 或 Bitmap 渲染器
- 自动管理 canvas 生命周期
- 流式 API 支持（WritableStream）

### 3. 使用专业渲染器

```typescript
const createVideoFrameRenderer = async () => {
  if (WebGLVideoFrameRenderer.isSupported) {
    // 优先使用 WebGL 渲染器（性能更好）
    const renderer = new WebGLVideoFrameRenderer()
    return { renderer, element: renderer.canvas }
  }
  // 降级到 Bitmap 渲染器
  const renderer = new BitmapVideoFrameRenderer()
  return { renderer, element: renderer.canvas }
}
```

### 4. 使用 TransformStream 保证帧顺序

```typescript
const transformStream = new TransformStream<VideoPacket, VideoPacket>({
  transform(packet, controller) {
    if (packet.type === 'configuration') {
      controller.enqueue(packet)
      configurationPacketSent = true
      // 发送所有等待的数据帧
      if (pendingDataPackets.length > 0) {
        pendingDataPackets.forEach(p => controller.enqueue(p))
        pendingDataPackets = []
      }
      return
    }
    
    // 如果配置帧还没发送，缓存数据帧
    if (packet.type === 'data' && !configurationPacketSent) {
      pendingDataPackets.push(packet)
      return
    }
    
    controller.enqueue(packet)
  },
})
```

### 5. 使用 ReadableStream 和 WritableStream

```typescript
const videoStream = new ReadableStream<VideoPacket>({
  start(controller) {
    socketRef.current?.on('video-data', (data) => {
      controller.enqueue(data)
    })
  }
})

// 通过管道连接到解码器
videoStream
  .pipeThrough(transformStream)
  .pipeTo(decoder.writable)
```

### 6. 自动管理 Canvas 尺寸

```typescript
decoder.sizeChanged(({ width, height }) => {
  setScreenInfo({ width, height })
  updateCanvasSize()
})
```

## 关键改进点

### 之前的实现（有问题）

```typescript
// ❌ 直接使用原生 VideoDecoder
const decoder = new VideoDecoder({
  output: (frame) => {
    ctx.drawImage(frame, 0, 0)
    frame.close()
  },
  error: (e) => console.error(e)
})

// ❌ 手动处理每一帧
socket.on('video-data', (packet) => {
  const chunk = new EncodedVideoChunk({
    type: packet.keyframe ? 'key' : 'delta',
    timestamp: packet.pts || 0,
    data: packet.data,
  })
  decoder.decode(chunk)
})
```

### 现在的实现（正确）

```typescript
// ✅ 使用专业的 WebCodecsVideoDecoder
const { renderer, element } = await createVideoFrameRenderer()
const decoder = new WebCodecsVideoDecoder({
  codec: codecId,
  renderer,
})

// ✅ 使用流式 API
const videoStream = setupVideoStream(metadata)
videoStream.pipeTo(decoder.writable)
```

## 技术优势

1. **更好的性能**：WebGL 渲染器使用 GPU 加速
2. **更稳定**：自动处理帧顺序和同步问题
3. **更简洁**：不需要手动管理 canvas 和渲染逻辑
4. **更专业**：使用 Scrcpy 官方推荐的解码方案

## 参考实现

完整参考了 AutoGLM-GUI 项目的实现：
- `AutoGLM-GUI/frontend/src/components/ScrcpyPlayer.tsx`

## 测试结果

- ✅ Socket.IO 连接成功
- ✅ 视频元数据接收正常
- ✅ 配置帧和数据帧正确处理
- ✅ Canvas 自动创建和添加到 DOM
- ✅ 视频画面正常显示
- ✅ 尺寸自适应容器

## 文件修改

- `frontend/src/components/ScrcpyPlayer.tsx` - 完全重写，使用专业库
- `frontend/package.json` - 添加依赖

## 下一步

如果还有黑屏问题，检查：
1. 浏览器是否支持 WebCodecs（Chrome 94+, Edge 94+）
2. 后端是否正确发送配置帧
3. 网络连接是否稳定
4. 控制台是否有错误日志
